const pool = require('../config/database');

class TrainingDataModel {
  // Create a new training data record
  async createTrainingData(trainingData) {
    const {
      model_id,
      start_date,
      end_date,
      dataset_size,
      features_used,
      status = 'pending'
    } = trainingData;

    const [result] = await pool.execute(
      'INSERT INTO training_data (model_id, start_date, end_date, dataset_size, features_used, status) VALUES (?, ?, ?, ?, ?, ?)',
      [model_id, start_date, end_date, dataset_size, features_used, status]
    );
    
    return result.insertId;
  }

  // Get training data by ID
  async getTrainingDataById(trainingId) {
    const [rows] = await pool.execute(
      'SELECT * FROM training_data WHERE id = ?',
      [trainingId]
    );
    return rows[0];
  }

  // Get all training data for a model
  async getTrainingDataByModelId(modelId) {
    const [rows] = await pool.execute(
      'SELECT * FROM training_data WHERE model_id = ? ORDER BY created_at DESC',
      [modelId]
    );
    return rows;
  }

  // Update training data status
  async updateTrainingStatus(trainingId, status, trainingMetrics = null) {
    const [result] = await pool.execute(
      'UPDATE training_data SET status = ?, training_metrics = ? WHERE id = ?',
      [status, trainingMetrics ? JSON.stringify(trainingMetrics) : null, trainingId]
    );
    return result.affectedRows > 0;
  }

  // Get the latest completed training data
  async getLatestCompletedTraining() {
    const [rows] = await pool.execute(
      'SELECT * FROM training_data WHERE status = "completed" ORDER BY end_date DESC LIMIT 1'
    );
    
    if (rows.length > 0 && rows[0].training_metrics) {
      try {
        rows[0].training_metrics = JSON.parse(rows[0].training_metrics);
      } catch (e) {
        console.error('Error parsing training metrics:', e);
      }
    }
    
    return rows[0] || null;
  }

  // Get recommendations generated by a specific training
  async getRecommendationsByTrainingId(trainingId) {
    const [rows] = await pool.execute(
      'SELECT * FROM recommendations WHERE training_id = ?',
      [trainingId]
    );
    return rows;
  }

  // Get training history with performance metrics
  async getTrainingHistory(limit = 10) {
    const [rows] = await pool.execute(`
      SELECT td.*, mp.model_version, mp.accuracy, mp.precision_score, mp.recall, mp.f1_score 
      FROM training_data td
      JOIN model_performance mp ON td.model_id = mp.id
      ORDER BY td.created_at DESC
      LIMIT ?
    `, [limit]);
    
    rows.forEach(row => {
      if (row.training_metrics) {
        try {
          row.training_metrics = JSON.parse(row.training_metrics);
        } catch (e) {
          console.error('Error parsing training metrics:', e);
        }
      }
      
      if (row.features_used) {
        try {
          row.features_used = JSON.parse(row.features_used);
        } catch (e) {
          // If not JSON, keep as is
        }
      }
    });
    
    return rows;
  }
}

module.exports = new TrainingDataModel();